{"meta":{"title":"Continuous Development","subtitle":"Eureka Moment! Web, Mobile, Cloud","description":"Java, Spring, JPA, Javascript, MicroServices Architecture","author":"GLiDER","url":"https://gliderwiki.github.io"},"pages":[],"posts":[{"title":"Javascript-ES6 part 2","slug":"Javascript-ES6-part-2","date":"2017-08-01T20:13:11.000Z","updated":"2017-08-02T20:14:21.000Z","comments":true,"path":"2017/08/02/Javascript-ES6-part-2/","link":"","permalink":"https://gliderwiki.github.io/2017/08/02/Javascript-ES6-part-2/","excerpt":"","text":"Arrow Function화살표 함수 표현(arrow function expression)은 익명 함수 표기법으로 function 표현에 비해 구문이 짧고, 자신의 this, arguments, super 등을 바인딩 하지 않는다. 기본 표기법은 아래와 같다. () =&gt; { ... } Identifier =&gt; Expression 형태의 구문인데 아래 그림을 보면 더 정확하게 이해할 수 있을것이다. 전달하고자 하는 파라미터가 하나일 경우 괄호를 생략할 수 있고, 리턴 되는 리터럴에 따라 body를 감싸서 보낼 수 도 있다.. Example1params =&gt; (&#123;foo: bar&#125;) 아래의 예제를 살펴보면 기존 구문과의 차이에 대해서 명확히 알 수 있다.둘다 동일한 기능을 수행한다.12345678910111213var lang = [ \"Javascript\", \"ASP\", \"JAVA\", \"Python\"];var normal = lang.map( function(s) &#123; return s.length &#125;);var arrow = lang.map( s =&gt; s.length );console.log('normal = ' + normal);console.log('arrow = ' + arrow); 함수의 본문은 return을 생략할 수 있다. Example123var func = x =&gt; x * x; // 간결한 구문, \"return\" 생략 var func = (x, y) =&gt; &#123; return x + y; &#125;; // 블록 본문일 경우 \"return\" 명시 객체 리터럴은 괄호로 감싸야 한다. 아래의 예제를 보자123456789101112var lang = [ \"Javascript\", \"ASP\", \"JAVA\", \"Python\"];const myLanguage = lang.map( (value) =&gt; &#123; return `Hello $&#123;value&#125; World\\n`;&#125;);console.log(myLanguage); return 구문을 생략할 경우 undefined 가 lang의 갯수만큼 출력될 것이다. 애로우 펑션의 가장 큰 장점은 복잡한 수준의 코드를 간결하게 할 수 있다는 점이다.map, filter, reduce등을 이용하면 수십라인의 코드도 몇라인 수준의 명확한 코드로 작성될 수 있다. 아래의 예제를 살펴보자. 1234567891011const arrays = ['cherry', 'orange', 'apple', 'applemango', 'banana', 'orange', 'apple', 'applemango', 'banana', 'cherry', 'orange', 'watermelon' ];const groups = arrays.reduce( (total, fruit) =&gt; &#123; total[fruit] = (total[fruit] || 0) + 1 ; return total;&#125; , &#123;&#125;)console.log(groups)// &#123; apple: 2, applemango: 2, banana: 2, cherry: 2, orange: 3, watermelon: 1 &#125; arrays 안에 있는 자료를 그룹핑 카운트 하는 예제이지만 이와 같이map, filter, reduce와 같은 함수형 프로그래밍을 지원하는 메서드와 같이 사용하면 코드의 양이 줄어들고 강력한 기능을 제공할 수 있다. arrow function의 this context아래의 예제를 살펴보자.function 의 this123456789101112const thisObj = &#123; run() &#123; setTimeout(function () &#123; console.log(this === window); &#125;, 1000); &#125;, printRun() &#123; console.log('Hello Arrow Function!'); &#125;&#125;thisObj.run(); true 가 출력되는 것을 확인할 수 있다.따라서 thisObj안의 setTimeout 함수 내부에서 this.printRun()을 호출하게 되면 this를 통한 내부 호출을 하지 않기 때문에 에러가 발생하게 된다.this 가 thisObj의 printRun()을 호출하고자 할 때에는 setTimeout().bind(this)로 감싸주어야 정상적으로 접근이 된다.Arrow function일 경우 반대의 상황이 벌어진다. arrow function 의 this12345678910111213const thisObj = &#123; run() &#123; setTimeout( () =&gt; &#123; console.log(this === window); // false this.printRun(); &#125;, 1000); &#125;, printRun() &#123; console.log('Hello Arrow Function!'); &#125;&#125;thisObj.run(); arrow function 으로 변환한 내부에서는 this가 window 가 아닌 thisObj를 가르킨다.따라서 따로 bind(this)를 통해 처리 하지 않더라도 정상적으로 내부의 printRun() 메서드가 호출이 되는 것을 확인할 수 있다. ClassJavascript 는 프로토타입 기반의 객체지향 프로그래밍이 가능하다.이를 위해 prototype 이나 Object.create 구문등으로 Class스럽게 코드를 작성했지만 ES6에서는 Class 가 지원이 되었다. 123456789101112131415161718192021class Member &#123; constructor(userId) &#123; this._userId = userId; &#125; findId() &#123; return 'Member ID = ' + this._userId; &#125;&#125;class Login extends Member &#123; findId() &#123; return '[Login findId] ' + super.findId(); &#125;&#125;var member = new Member('GLiDER');console.log(member.findId()); // Member ID = GLiDERvar login = new Login('QuicK');console.log(login.findId()); // [Login findId] Member ID = QuicK ModuleNew Built-In Methods","categories":[{"name":"Front","slug":"Front","permalink":"https://gliderwiki.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"https://gliderwiki.github.io/categories/Front/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gliderwiki.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://gliderwiki.github.io/tags/ES6/"}]},{"title":"AWS","slug":"AWS","date":"2017-08-01T13:44:40.000Z","updated":"2017-08-01T13:45:03.000Z","comments":true,"path":"2017/08/01/AWS/","link":"","permalink":"https://gliderwiki.github.io/2017/08/01/AWS/","excerpt":"","text":"","categories":[{"name":"Infra","slug":"Infra","permalink":"https://gliderwiki.github.io/categories/Infra/"},{"name":"AWS","slug":"Infra/AWS","permalink":"https://gliderwiki.github.io/categories/Infra/AWS/"}],"tags":[]},{"title":"Java8","slug":"Java8","date":"2017-08-01T13:43:05.000Z","updated":"2017-08-01T13:47:31.000Z","comments":true,"path":"2017/08/01/Java8/","link":"","permalink":"https://gliderwiki.github.io/2017/08/01/Java8/","excerpt":"","text":"","categories":[{"name":"Server","slug":"Server","permalink":"https://gliderwiki.github.io/categories/Server/"},{"name":"Java","slug":"Server/Java","permalink":"https://gliderwiki.github.io/categories/Server/Java/"}],"tags":[{"name":"Java8","slug":"Java8","permalink":"https://gliderwiki.github.io/tags/Java8/"},{"name":"Lambda","slug":"Lambda","permalink":"https://gliderwiki.github.io/tags/Lambda/"},{"name":"Stream","slug":"Stream","permalink":"https://gliderwiki.github.io/tags/Stream/"}]},{"title":"Javascript-ES6 part 1","slug":"Javascript-ES6","date":"2017-08-01T08:30:34.000Z","updated":"2017-08-02T15:31:13.000Z","comments":true,"path":"2017/08/01/Javascript-ES6/","link":"","permalink":"https://gliderwiki.github.io/2017/08/01/Javascript-ES6/","excerpt":"","text":"let, const기존 ES5에서는 변수를 선언할 때 var 키워드를 사용하였다.그러나 var의 경우 전역변수로 간주되거나 의도치 않게 중복된 변수 선언을 한다던가변수 호이스팅(Variable Hoisting)이 일어나 변수를 선언하기 전에 참조가 가능한 문제가 발생하게 된다. 이 때문에 예기치 못한 참조나 의존으로 인한 side effect이 있어 복잡도가 증가하기 때문에 var의 단점을 보완한 let과 const 라는 키워드를 정의하였다. letlet은 Block-level scope를 갖는다. 코드 블럭 외부에서 참조할 경우 ReferenceError 가 발생한다.또한 let으로 선언된 변수를 중복해서 선언할 경우 Syntax에러가 발생한다. Example1234567891011121314var global = \"abc\";function variable() &#123; let local = \"123\"; console.log('local : ' + local); // 123&#125;variable();console.log('global : ' + global); // abc console.log('window.global : ' + global); // abc console.log('local : ' + local); // ReferenceError: local is not defined 이와 같이 블럭 외부에서 참조할 경우 레퍼런스 에러가 발생하는 것을 확인할 수 있다.전역적 값을 갖는 변수로 인한 문제를 해결하기 위해 지역 변수의 스코프를 갖는 동시에 중복선언이 되지 않기 때문에 가급적 코드 블럭 내에서는 let을 이용하여 변수를 선언하는게 좋다. const변하지 않는 값을 위해 사용하는데, let과 비슷하지만 const는 초기화 이후 재할당이 금지 된다.또한 선언과 동시에 초기화를 해주어야 한다. 그렇지 않을 경우 아래와 같은 에러가 발생한다. SyntaxError: Missing initializer in const declaration const가 재할당을 할수 없다고는 하나 객체 리터럴의 경우 값의 추가 혹은 할당된 객체의 내용은 변경할 수 있다.객체 리터럴의 경우 const에 지정된 주소값의 변경이 되지 않는것이지 객체의 프로퍼티 값은 변경이 가능하다. 123456789function myList() &#123; const list = [\"java\", \"javascript\", \"mysql\"]; console.log('list = ' + list); // java,javascript,mysql list.push(\"node\"); console.log('push list = ' + list); // java,javascript,mysql,node&#125;myList(); Template Literal백틱 문자 ` 를 이용한 멀티 라인 지원과 값 내의 이스케이프 문자열 치환을 해결하였다.JSON 문자열을 파싱한 후 DOM 에 렌더링 할 때 쌍 따옴표나 홑따옴표로 이스케이프 문자열을 처리할 때를 생각해보자.이 때 불편한점은 문자열처리와 변수를 결합할 때 이스케이프 문자열의 오류 처리에 많은 집중을 해야 한다. 이 때 변수들의 처리를 ${변수명} 과 같은 형태로 처리할 수 있으며 이를 Template Literal 이라고 한다. 아래의 예제를 JSBin 이나 console을 통해 실행해보자. 1234567891011121314151617const data = [ &#123; name: 'gildong', email: 'gildong@gmail.com', age : 30 &#125;, &#123; name: 'john doe', email: 'johndoe@gmail.com', age : 32 &#125; ]const template = `이름은 $&#123;data[1].name&#125; 이고, 나이는 $&#123;data[1].age&#125; 입니다.`;console.log(template); 결과값은 “이름은 john doe 이고, 나이는 32 입니다.”라고 출력되는 것을 확인 할 수 있다. 백틱문자는 여러 라인으로 작성할 수 있고, 내부에 HTML 태그 또한 작성할 수 있다.이를 활용하여 document의 DOM에 HTML Tag 가 포함된 template 리터럴을 쉽게 추가해줄 수 있다. 기존의 javascript 에서는 Spread OperatorDestructuringMap, WeakMapMapMap은 Key와 Value을 서로 연결(매핑)시켜 저장하며 저정된 순서대로 각 요소들을 반복적으로 접근할 수 있도록 한다. Map API 확인하기 1234let myMap = new Map([ ['key1' , 'value1'], ['key2' , 'value2']]); WeakMap12 Set, WeakSetSetSet운 중복을 허용하지 않는 값들의 집합이다. 입력된 순서에따라 저장된 요소를 반복처리할 수 있다.또한 배열과 달리 delete 메소드를 이용하여 요소의 값을 삭제할 수 있으며, indexOf 메소드로 값을 확인하는것 보다 has 가 더 빠르다 Set Api 확인하기 12345678let mySet = new Set();mySet.add(\"1st\");mySet.add(\"2nd\");mySet.add(\"3rd\");mySet.forEach(function(value) &#123; console.log(\"value = \" + value);&#125;); 순차적으로 값이 출력되는 것을 확인 할 수 있다. Set 내부에 특정한 값이 존재하는지 체크하려면 아래와 같다.123if (mySet.has(\"1st\")) &#123;... &#125; Set 내부의 값을 삭제하려면 delete 메소드를 이용한다.1mySet.delete(\"1st\"); WeakSet","categories":[{"name":"Front","slug":"Front","permalink":"https://gliderwiki.github.io/categories/Front/"},{"name":"Javascript","slug":"Front/Javascript","permalink":"https://gliderwiki.github.io/categories/Front/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://gliderwiki.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://gliderwiki.github.io/tags/ES6/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-01T08:02:15.000Z","updated":"2017-08-01T08:02:15.000Z","comments":true,"path":"2017/08/01/hello-world/","link":"","permalink":"https://gliderwiki.github.io/2017/08/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}